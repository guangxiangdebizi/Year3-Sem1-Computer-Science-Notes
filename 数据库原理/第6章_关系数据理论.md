# 第6章 关系数据理论

## 学习目标
- 理解函数依赖的概念和性质
- 掌握码的概念和求解方法
- 理解范式的概念和作用
- 掌握1NF、2NF、3NF、BCNF的定义和判断
- 学会数据库模式的规范化设计
- 了解多值依赖和4NF的概念

```mermaid
mindmap
  root((关系数据理论))
    函数依赖
      完全函数依赖
      部分函数依赖
      传递函数依赖
      函数依赖集闭包
    码的概念
      超码
      候选码
      主码
      外码
    范式理论
      第一范式1NF
      第二范式2NF
      第三范式3NF
      BC范式BCNF
      第四范式4NF
    规范化
      模式分解
      无损连接分解
      保持函数依赖分解
    多值依赖
      多值依赖定义
      平凡多值依赖
      非平凡多值依赖
```

## 6.1 问题的提出

### 6.1.1 关系模式中可能存在的问题

考虑学生选课关系：
```
Student(Sno, Sname, Sdept, Mname, Cno, Grade)
```

**存在的问题：**

```mermaid
graph TD
    A[关系模式问题] --> B[数据冗余<br/>Data Redundancy]
    A --> C[更新异常<br/>Update Anomaly]
    A --> D[插入异常<br/>Insert Anomaly]
    A --> E[删除异常<br/>Delete Anomaly]
    
    B --> B1[学生信息重复存储]
    C --> C1[修改学生信息需要<br/>修改多个元组]
    D --> D1[无法单独插入<br/>学生或课程信息]
    E --> E1[删除选课记录可能<br/>丢失学生信息]
    
    style B fill:#ffcdd2
    style C fill:#fff3e0
    style D fill:#e8f5e8
    style E fill:#bbdefb
```

1. **数据冗余**：学生姓名、系别、系主任在多个元组中重复出现
2. **更新异常**：修改学生系别时，需要修改多个元组
3. **插入异常**：无法插入尚未选课的学生信息
4. **删除异常**：删除学生的最后一门选课记录时，学生信息也被删除

## 6.2 规范化

### 6.2.1 函数依赖

#### 函数依赖的定义
设R(U)是一个关系模式，X和Y是U的子集。如果对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称"X函数确定Y"或"Y函数依赖于X"，记作X→Y。

```mermaid
graph LR
    A[学号 Sno] --> B[姓名 Sname]
    A --> C[年龄 Sage]
    A --> D[系别 Sdept]
    
    E[系别 Sdept] --> F[系主任 Mname]
    
    G[学号+课程号<br/>Sno,Cno] --> H[成绩 Grade]
    
    style A fill:#e3f2fd
    style E fill:#e8f5e8
    style G fill:#fff3e0
```

#### 函数依赖的类型

```mermaid
graph TD
    A[函数依赖类型] --> B[完全函数依赖<br/>Full Functional Dependency]
    A --> C[部分函数依赖<br/>Partial Functional Dependency]
    A --> D[传递函数依赖<br/>Transitive Functional Dependency]
    
    B --> B1[Y完全函数依赖于X<br/>X的任何真子集都不能确定Y]
    C --> C1[Y部分函数依赖于X<br/>X的某个真子集可以确定Y]
    D --> D1[X→Y, Y→Z, Y不依赖于Z<br/>则Z传递函数依赖于X]
    
    subgraph "示例"
        E[Sno,Cno → Grade<br/>完全函数依赖]
        F[Sno,Cno → Sname<br/>部分函数依赖]
        G[Sno → Sdept → Mname<br/>传递函数依赖]
    end
```

### 6.2.2 码

#### 码的定义
设K为R<U,F>中的属性或属性组合。若K→U，则K称为R的一个**超码**。
若K是超码，且K的任何真子集都不是超码，则K称为R的**候选码**。

```mermaid
graph TD
    A[码的层次结构] --> B[超码 Super Key]
    B --> C[候选码 Candidate Key]
    C --> D[主码 Primary Key]
    
    B --> B1[能唯一标识元组的<br/>属性或属性组]
    C --> C1[最小的超码<br/>去掉任何属性都不是超码]
    D --> D1[从候选码中选择的<br/>一个作为主码]
    
    subgraph "示例：学生选课关系"
        E[超码: {Sno,Cno,Sname}]
        F[候选码: {Sno,Cno}]
        G[主码: {Sno,Cno}]
        H[主属性: Sno, Cno]
        I[非主属性: Sname, Grade]
    end
    
    style D fill:#ffcdd2
    style H fill:#e8f5e8
    style I fill:#bbdefb
```

### 6.2.3 范式

#### 第一范式（1NF）
如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。

```mermaid
graph LR
    subgraph "不满足1NF"
        A[学生表<br/>学号|姓名|联系方式]
        B[001|张三|电话:123 邮箱:abc@qq.com]
    end
    
    subgraph "满足1NF"
        C[学生表<br/>学号|姓名|电话|邮箱]
        D[001|张三|123|abc@qq.com]
    end
    
    A --> C
    style A fill:#ffcdd2
    style C fill:#e8f5e8
```

#### 第二范式（2NF）
若R∈1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R∈2NF。

```mermaid
flowchart TD
    A[检查2NF] --> B{是否为1NF?}
    B -->|否| C[不是2NF]
    B -->|是| D{非主属性是否完全<br/>函数依赖于候选码?}
    D -->|否| E[存在部分函数依赖<br/>不是2NF]
    D -->|是| F[满足2NF]
    
    subgraph "违反2NF的例子"
        G[选课关系: Sno,Cno,Sname,Grade<br/>Sno,Cno → Sname 部分依赖]
    end
    
    subgraph "2NF分解"
        H[学生: Sno,Sname]
        I[选课: Sno,Cno,Grade]
    end
    
    style E fill:#ffcdd2
    style F fill:#e8f5e8
```

#### 第三范式（3NF）
设关系模式R<U,F>∈1NF，若R中不存在这样的码X、属性组Y及非主属性Z（Z⊄Y），使得X→Y，Y→Z，则称R<U,F>∈3NF。

```mermaid
graph TD
    A[3NF检查] --> B[消除传递函数依赖]
    
    subgraph "违反3NF的例子"
        C[学生关系: Sno,Sname,Sdept,Mname<br/>Sno → Sdept → Mname 传递依赖]
    end
    
    subgraph "3NF分解"
        D[学生: Sno,Sname,Sdept]
        E[系: Sdept,Mname]
    end
    
    C --> D
    C --> E
    
    style C fill:#ffcdd2
    style D fill:#e8f5e8
    style E fill:#e8f5e8
```

#### BC范式（BCNF）
设关系模式R<U,F>∈1NF，若X→Y且Y⊄X时X必含有码，则R<U,F>∈BCNF。

```mermaid
graph TD
    A[范式层次关系] --> B[1NF<br/>属性不可分]
    B --> C[2NF<br/>消除部分函数依赖]
    C --> D[3NF<br/>消除传递函数依赖]
    D --> E[BCNF<br/>消除主属性对码的<br/>部分和传递依赖]
    
    F[BCNF ⊆ 3NF ⊆ 2NF ⊆ 1NF]
    
    style E fill:#4caf50
    style D fill:#8bc34a
    style C fill:#cddc39
    style B fill:#ffeb3b
```

## 6.3 数据依赖的公理系统

### 6.3.1 Armstrong公理系统

```mermaid
graph TD
    A[Armstrong公理系统] --> B[基本规则]
    A --> C[推导规则]
    
    B --> B1[自反律<br/>若Y⊆X⊆U，则X→Y]
    B --> B2[增广律<br/>若X→Y，则XZ→YZ]
    B --> B3[传递律<br/>若X→Y，Y→Z，则X→Z]
    
    C --> C1[合并规则<br/>若X→Y，X→Z，则X→YZ]
    C --> C2[伪传递规则<br/>若X→Y，WY→Z，则XW→Z]
    C --> C3[分解规则<br/>若X→Y，Z⊆Y，则X→Z]
    
    style B1 fill:#e3f2fd
    style B2 fill:#e3f2fd
    style B3 fill:#e3f2fd
    style C1 fill:#f3e5f5
    style C2 fill:#f3e5f5
    style C3 fill:#f3e5f5
```

### 6.3.2 函数依赖集的闭包

**算法：求属性集X关于函数依赖集F的闭包X+**

```mermaid
flowchart TD
    A[开始] --> B[X+ = X]
    B --> C[对F中每个函数依赖Y→Z]
    C --> D{Y ⊆ X+?}
    D -->|是| E[X+ = X+ ∪ Z]
    D -->|否| F[检查下一个依赖]
    E --> G{X+有变化?}
    F --> G
    G -->|是| C
    G -->|否| H[输出X+]
    
    style A fill:#4caf50
    style H fill:#f44336
```

## 6.4 模式的分解

### 6.4.1 模式分解的标准

```mermaid
graph TD
    A[模式分解标准] --> B[无损连接性<br/>Lossless Join]
    A --> C[保持函数依赖<br/>Dependency Preservation]
    
    B --> B1[分解后通过自然连接<br/>能够恢复原关系]
    C --> C1[分解后函数依赖集<br/>与原来等价]
    
    subgraph "理想分解"
        D[既无损连接<br/>又保持函数依赖]
    end
    
    subgraph "实际情况"
        E[3NF: 一定存在既无损连接<br/>又保持函数依赖的分解]
        F[BCNF: 一定存在无损连接分解<br/>但不一定保持函数依赖]
    end
    
    style D fill:#4caf50
    style E fill:#8bc34a
    style F fill:#ff9800
```

### 6.4.2 3NF的分解算法

```mermaid
flowchart TD
    A[输入: R<U,F>] --> B[计算F的最小函数依赖集Fm]
    B --> C[对Fm中每个函数依赖X→Y<br/>构造关系模式XY]
    C --> D{是否有关系模式<br/>包含R的候选码?}
    D -->|否| E[添加一个包含<br/>R候选码的关系模式]
    D -->|是| F[检查是否有关系模式<br/>被其他模式包含]
    E --> F
    F --> G[删除被包含的关系模式]
    G --> H[输出分解结果]
    
    style A fill:#4caf50
    style H fill:#f44336
```

## 6.5 多值依赖

### 6.5.1 多值依赖的定义

设R(U)是一个关系模式，X、Y、Z是U的子集，且Z=U-X-Y。多值依赖X→→Y成立，当且仅当对R的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。

```mermaid
graph TD
    A[多值依赖示例] --> B[课程-教师-参考书关系]
    
    subgraph "关系实例"
        C[数据库|张三|数据库系统概论]
        D[数据库|张三|数据库原理]
        E[数据库|李四|数据库系统概论]
        F[数据库|李四|数据库原理]
    end
    
    B --> G[课程 →→ 教师<br/>课程 →→ 参考书]
    
    subgraph "4NF分解"
        H[课程-教师: 课程,教师]
        I[课程-参考书: 课程,参考书]
    end
    
    style G fill:#fff3e0
    style H fill:#e8f5e8
    style I fill:#e8f5e8
```

### 6.5.2 第四范式（4NF）

关系模式R<U,F>∈1NF，如果对于R的每个非平凡多值依赖X→→Y（Y⊄X），X都含有码，则R<U,F>∈4NF。

## 6.6 学习检查点

### 6.6.1 重点概念总结

```mermaid
mindmap
  root((重点概念))
    函数依赖
      完全函数依赖
      部分函数依赖
      传递函数依赖
    码
      超码
      候选码
      主码
      主属性vs非主属性
    范式
      1NF消除非原子值
      2NF消除部分函数依赖
      3NF消除传递函数依赖
      BCNF消除主属性依赖
    分解
      无损连接
      保持函数依赖
      分解算法
```

### 6.6.2 练习题

1. **函数依赖判断题**
   - 给定关系模式和函数依赖集，判断各种函数依赖关系
   - 求属性集的闭包
   - 求候选码

2. **范式判断题**
   - 判断关系模式属于哪个范式
   - 找出违反范式的函数依赖
   - 进行模式分解

3. **综合应用题**
   - 设计满足特定范式的关系模式
   - 分析实际问题中的数据依赖关系

### 6.6.3 思考题

1. 为什么需要数据库规范化？规范化的优缺点是什么？
2. 3NF和BCNF的区别是什么？什么情况下需要使用BCNF？
3. 如何在保证数据一致性和查询效率之间找到平衡？
4. 多值依赖与函数依赖有什么区别和联系？

## 6.7 实践应用

### 6.7.1 规范化设计步骤

```mermaid
flowchart TD
    A[需求分析] --> B[确定属性和函数依赖]
    B --> C[构造初始关系模式]
    C --> D[检查范式级别]
    D --> E{满足目标范式?}
    E -->|否| F[进行模式分解]
    F --> D
    E -->|是| G[验证分解质量]
    G --> H[优化设计]
    
    style A fill:#4caf50
    style H fill:#f44336
```

### 6.7.2 常见设计模式

1. **一对一关系**：可以合并为一个关系
2. **一对多关系**：在"多"的一方添加外码
3. **多对多关系**：需要建立中间关系表

---

**本章小结**：关系数据理论为数据库设计提供了理论基础，通过函数依赖分析和范式理论，可以设计出结构良好、避免异常的关系模式。掌握这些理论对于数据库设计和优化具有重要意义。