# 第10章 并发控制

## 学习目标
- 理解并发控制的基本概念和重要性
- 掌握事务调度和串行化理论
- 了解并发操作可能产生的问题
- 掌握封锁协议和两段锁协议
- 理解死锁的产生、预防和解除
- 了解时间戳排序和多版本并发控制
- 掌握隔离级别和并发控制的实现

```mermaid
mindmap
  root((并发控制))
    并发问题
      丢失修改
      不可重复读
      读脏数据
      幻读
    并发控制方法
      封锁方法
        排他锁
        共享锁
        两段锁协议
      时间戳方法
        基本时间戳
        多版本时间戳
      乐观控制方法
        验证技术
        多版本控制
    死锁处理
      死锁预防
      死锁检测
      死锁解除
    隔离级别
      读未提交
      读已提交
      可重复读
      串行化
```

## 10.1 并发控制概述

### 10.1.1 并发操作的必要性

```mermaid
graph TD
    A[并发操作的必要性] --> B[提高系统效率]
    A --> C[改善系统响应时间]
    A --> D[提高系统吞吐量]
    
    B --> B1[CPU和I/O可以并行工作<br/>减少处理器空闲时间<br/>充分利用系统资源]
    
    C --> C1[减少用户等待时间<br/>提高用户体验<br/>支持更多并发用户]
    
    D --> D1[单位时间内处理更多事务<br/>提高系统整体性能<br/>降低系统运行成本]
    
    subgraph "串行 vs 并发"
        E[串行执行<br/>T1→T2→T3<br/>总时间: 30秒]
        F["并发执行<br/>T1||T2||T3<br/>总时间: 12秒"]
    end
    
    style F fill:#4caf50
    style E fill:#ffcdd2
```

### 10.1.2 并发操作带来的问题

```mermaid
graph TD
    A[并发操作的问题] --> B[丢失修改<br/>Lost Update]
    A --> C[不可重复读<br/>Non-repeatable Read]
    A --> D[读脏数据<br/>Dirty Read]
    A --> E[幻读<br/>Phantom Read]
    
    B --> B1[两个事务同时修改同一数据<br/>一个事务的修改被另一个覆盖]
    
    C --> C1[一个事务内多次读取同一数据<br/>得到不同的结果]
    
    D --> D1[一个事务读取了另一个事务<br/>未提交的修改数据]
    
    E --> E1[一个事务内多次查询<br/>结果集的记录数不同]
    
    subgraph "问题严重程度"
        F[丢失修改: 最严重]
        G[读脏数据: 严重]
        H[不可重复读: 中等]
        I[幻读: 较轻]
    end
    
    style F fill:#f44336
    style G fill:#ff9800
    style H fill:#ff5722
    style I fill:#ffc107
```

### 10.1.3 并发控制的任务

```mermaid
flowchart TD
    A[并发控制的任务] --> B[对并发操作进行正确调度]
    B --> C[保证事务的隔离性]
    C --> D[保证数据库的一致性]
    D --> E[使数据库处于正确状态]
    
    subgraph "调度策略"
        F[串行调度<br/>Serial Schedule]
        G[可串行化调度<br/>Serializable Schedule]
        H[非串行调度<br/>Non-serial Schedule]
    end
    
    B --> F
    B --> G
    B --> H
    
    F --> F1[事务逐个执行<br/>正确但效率低]
    G --> G1[并发执行但结果等价于串行<br/>正确且效率高]
    H --> H1[并发执行但可能产生错误<br/>需要避免]
    
    style G fill:#4caf50
    style F fill:#ff9800
    style H fill:#f44336
```

## 10.2 封锁

### 10.2.1 封锁的基本概念

```mermaid
graph TD
    A[封锁 Locking] --> B[排他锁 X锁]
    A --> C[共享锁 S锁]
    
    B --> B1[写锁 Write Lock<br/>事务T对数据对象A加X锁<br/>只有T能读取和修改A<br/>其他事务不能对A加任何锁]
    
    C --> C1[读锁 Read Lock<br/>事务T对数据对象A加S锁<br/>T可以读A但不能修改A<br/>其他事务只能对A加S锁]
    
    subgraph "锁的相容性矩阵"
        D[" "]
        D --> E[S锁]
        D --> F[X锁]
        E --> G[S锁: ✓]
        E --> H[X锁: ✗]
        F --> I[S锁: ✗]
        F --> J[X锁: ✗]
    end
    
    style B fill:#ffcdd2
    style C fill:#e8f5e8
```

### 10.2.2 封锁协议

```mermaid
graph TD
    A[封锁协议] --> B[一级封锁协议]
    A --> C[二级封锁协议]
    A --> D[三级封锁协议]
    
    B --> B1[事务T在修改数据R之前<br/>必须先对其加X锁<br/>直到事务结束才释放]
    B --> B2[防止: 丢失修改]
    
    C --> C1[在一级封锁协议基础上<br/>事务T在读取数据R之前<br/>必须先对其加S锁<br/>读完后即可释放S锁]
    C --> C2[防止: 丢失修改、读脏数据]
    
    D --> D1[在一级封锁协议基础上<br/>事务T在读取数据R之前<br/>必须先对其加S锁<br/>直到事务结束才释放]
    D --> D2[防止: 丢失修改、读脏数据、不可重复读]
    
    style D fill:#4caf50
    style C fill:#ff9800
    style B fill:#ffcdd2
```

### 10.2.3 两段锁协议

```mermaid
graph TD
    A[两段锁协议<br/>Two-Phase Locking] --> B[扩展阶段<br/>Growing Phase]
    A --> C[收缩阶段<br/>Shrinking Phase]
    
    B --> B1[事务可以申请获得任何数据项上<br/>任何类型的锁<br/>但不能释放任何锁]
    
    C --> C1[事务可以释放任何数据项上<br/>任何类型的锁<br/>但不能再申请任何锁]
    
    subgraph "两段锁时间线"
        D[事务开始] --> E[扩展阶段]
        E --> F[锁点<br/>Lock Point]
        F --> G[收缩阶段]
        G --> H[事务结束]
    end
    
    subgraph "锁的数量变化"
        I[锁数量]
        I --> J[递增]
        J --> K[达到最大值]
        K --> L[递减]
        L --> M[降为0]
    end
    
    style A fill:#e3f2fd
    style F fill:#4caf50
```

### 10.2.4 封锁的粒度

```mermaid
graph TD
    A[封锁粒度] --> B[数据库级]
    A --> C[表级]
    A --> D[页级]
    A --> E[记录级]
    A --> F[属性级]
    
    B --> B1[粒度最大<br/>并发度最低<br/>系统开销最小]
    
    C --> C1[粒度较大<br/>并发度较低<br/>系统开销较小]
    
    D --> D1[粒度中等<br/>并发度中等<br/>系统开销中等]
    
    E --> E1[粒度较小<br/>并发度较高<br/>系统开销较大]
    
    F --> F1[粒度最小<br/>并发度最高<br/>系统开销最大]
    
    subgraph "粒度选择原则"
        G[封锁粒度越小<br/>并发度越高<br/>系统开销越大]
        H[需要在并发度和<br/>系统开销之间权衡]
    end
    
    style E fill:#4caf50
```

## 10.3 死锁

### 10.3.1 死锁的概念

```mermaid
graph TD
    A[死锁 Deadlock] --> B[定义]
    A --> C[产生原因]
    A --> D[必要条件]
    
    B --> B1[两个或多个事务<br/>都在等待对方释放锁<br/>形成循环等待]
    
    C --> C1[多个事务同时执行<br/>申请锁的顺序不当<br/>持有锁的时间过长]
    
    D --> D1[互斥条件<br/>请求和保持条件<br/>不可剥夺条件<br/>循环等待条件]
    
    subgraph "死锁示例"
        E[事务T1] --> F[持有锁A<br/>等待锁B]
        G[事务T2] --> H[持有锁B<br/>等待锁A]
        F -.->|等待| H
        H -.->|等待| F
    end
    
    style E fill:#ffcdd2
    style G fill:#ffcdd2
```

### 10.3.2 死锁的预防

```mermaid
graph TD
    A[死锁预防] --> B[一次封锁法]
    A --> C[顺序封锁法]
    
    B --> B1[事务开始时一次性申请<br/>所有需要的锁<br/>要么全部获得，要么等待]
    B --> B2[优点: 不会发生死锁<br/>缺点: 降低并发度<br/>难以预知所需的锁]
    
    C --> C1[预先对数据对象规定<br/>一个封锁顺序<br/>所有事务都按此顺序申请锁]
    C --> C2[优点: 不会发生死锁<br/>缺点: 限制了事务的并发执行<br/>难以实现]
    
    subgraph "预防方法比较"
        D[一次封锁法<br/>实现简单<br/>并发度低]
        E[顺序封锁法<br/>实现复杂<br/>并发度中等]
    end
    
    style C fill:#4caf50
```

### 10.3.3 死锁的检测

```mermaid
graph TD
    A[死锁检测] --> B[等待图法]
    A --> C[超时法]
    
    B --> B1[构造事务等待图<br/>检测是否存在回路<br/>有回路则存在死锁]
    
    C --> C1[为每个事务设置等待时间限制<br/>超时则认为发生死锁<br/>撤销该事务]
    
    subgraph "等待图示例"
        D[T1] --> E[T2]
        E --> F[T3]
        F --> D
        G[检测到回路<br/>存在死锁]
    end
    
    subgraph "检测频率"
        H[定期检测<br/>系统开销固定]
        I[事件驱动检测<br/>检测及时]
    end
    
    style B fill:#4caf50
    style G fill:#f44336
```

### 10.3.4 死锁的解除

```mermaid
flowchart TD
    A[死锁解除] --> B[选择牺牲者]
    B --> C[撤销事务]
    C --> D[释放锁资源]
    D --> E[其他事务继续执行]
    
    subgraph "选择牺牲者的策略"
        F[撤销代价最小的事务]
        G[撤销占用资源最少的事务]
        H[撤销已执行时间最短的事务]
        I[撤销还需要执行时间最长的事务]
    end
    
    B --> F
    B --> G
    B --> H
    B --> I
    
    subgraph "撤销方式"
        J[完全撤销<br/>事务回滚到开始状态]
        K[部分撤销<br/>回滚到足以解除死锁]
    end
    
    C --> J
    C --> K
    
    style F fill:#4caf50
    style J fill:#ff9800
```

## 10.4 时间戳排序

### 10.4.1 时间戳的概念

```mermaid
graph TD
    A[时间戳排序] --> B[时间戳的分配]
    A --> C[时间戳的作用]
    A --> D[排序规则]
    
    B --> B1[系统时钟<br/>逻辑计数器<br/>事务标识符]
    
    C --> C1[确定事务的执行顺序<br/>解决读写冲突<br/>保证串行化]
    
    D --> D1[时间戳小的事务<br/>在时间戳大的事务之前执行<br/>TS(Ti) < TS(Tj) → Ti先于Tj]
    
    subgraph "时间戳示例"
        E[T1: TS=100]
        F[T2: TS=150]
        G[T3: TS=200]
        H[执行顺序: T1 → T2 → T3]
    end
    
    style D fill:#e3f2fd
```

### 10.4.2 基本时间戳排序算法

```mermaid
flowchart TD
    A[事务Ti请求读数据项X] --> B{TS(Ti) < WTS(X)?}
    B -->|是| C[拒绝读操作<br/>撤销Ti]
    B -->|否| D[允许读操作<br/>RTS(X) = max(RTS(X), TS(Ti))]
    
    E[事务Ti请求写数据项X] --> F{TS(Ti) < RTS(X)?}
    F -->|是| G[拒绝写操作<br/>撤销Ti]
    F -->|否| H{TS(Ti) < WTS(X)?}
    H -->|是| I[拒绝写操作<br/>撤销Ti]
    H -->|否| J[允许写操作<br/>WTS(X) = TS(Ti)]
    
    subgraph "时间戳标记"
        K[RTS(X): X的读时间戳<br/>最后读X的事务的时间戳]
        L[WTS(X): X的写时间戳<br/>最后写X的事务的时间戳]
    end
    
    style C fill:#f44336
    style G fill:#f44336
    style I fill:#f44336
    style D fill:#4caf50
    style J fill:#4caf50
```

### 10.4.3 多版本时间戳排序

```mermaid
graph TD
    A[多版本时间戳排序] --> B[版本管理]
    A --> C[读操作规则]
    A --> D[写操作规则]
    
    B --> B1[为每个数据项维护多个版本<br/>每个版本有读写时间戳<br/>版本按写时间戳排序]
    
    C --> C1[事务Ti读数据项X<br/>选择WTS ≤ TS(Ti)的最大版本<br/>更新该版本的RTS]
    
    D --> D1[事务Ti写数据项X<br/>检查是否有冲突<br/>创建新版本或拒绝操作]
    
    subgraph "版本示例"
        E[X的版本1: WTS=50, RTS=120]
        F[X的版本2: WTS=100, RTS=150]
        G[X的版本3: WTS=180, RTS=180]
    end
    
    style A fill:#e3f2fd
    style C1 fill:#4caf50
```

## 10.5 乐观并发控制

### 10.5.1 乐观控制的基本思想

```mermaid
graph TD
    A[乐观并发控制] --> B[基本假设]
    A --> C[执行阶段]
    A --> D[优缺点]
    
    B --> B1[冲突很少发生<br/>大多数事务不会冲突<br/>检测冲突比预防冲突代价小]
    
    C --> C1[读阶段<br/>Read Phase]
    C --> C2[验证阶段<br/>Validation Phase]
    C --> C3[写阶段<br/>Write Phase]
    
    D --> D1[优点: 无锁开销<br/>无死锁<br/>并发度高]
    D --> D2[缺点: 冲突时代价大<br/>可能饿死<br/>适用于读多写少]
    
    style C1 fill:#e8f5e8
    style C2 fill:#fff3e0
    style C3 fill:#ffcdd2
```

### 10.5.2 验证技术

```mermaid
flowchart TD
    A[事务Ti进入验证阶段] --> B[检查与已提交事务的冲突]
    B --> C{是否存在冲突?}
    C -->|否| D[验证通过<br/>进入写阶段]
    C -->|是| E[验证失败<br/>撤销事务]
    
    subgraph "冲突检测条件"
        F[对于任意已提交事务Tj<br/>满足以下条件之一:]
        G[1. finish(Tj) < start(Ti)]
        H[2. start(Ti) < finish(Tj) < validation(Ti)<br/>且 WS(Tj) ∩ RS(Ti) = ∅]
        I[3. start(Ti) < start(Tj) < validation(Ti)<br/>且 WS(Tj) ∩ RS(Ti) = ∅<br/>且 WS(Tj) ∩ WS(Ti) = ∅]
    end
    
    B --> F
    F --> G
    F --> H
    F --> I
    
    style D fill:#4caf50
    style E fill:#f44336
```

### 10.5.3 多版本并发控制

```mermaid
graph TD
    A[多版本并发控制<br/>MVCC] --> B[版本链]
    A --> C[可见性规则]
    A --> D[垃圾回收]
    
    B --> B1[每个数据项维护版本链<br/>新版本添加到链头<br/>旧版本保留一段时间]
    
    C --> C1[事务只能看到<br/>在其开始时间之前<br/>已提交的版本]
    
    D --> D1[定期清理不再需要的<br/>旧版本数据<br/>释放存储空间]
    
    subgraph "MVCC优点"
        E[读不阻塞写<br/>写不阻塞读<br/>无读锁<br/>高并发性能]
    end
    
    subgraph "MVCC缺点"
        F[存储开销大<br/>垃圾回收复杂<br/>版本管理开销]
    end
    
    style E fill:#4caf50
    style F fill:#ff9800
```

## 10.6 隔离级别

### 10.6.1 SQL标准隔离级别

```mermaid
graph TD
    A[SQL隔离级别] --> B[读未提交<br/>Read Uncommitted]
    A --> C[读已提交<br/>Read Committed]
    A --> D[可重复读<br/>Repeatable Read]
    A --> E[串行化<br/>Serializable]
    
    B --> B1[最低隔离级别<br/>可能读到脏数据<br/>不可重复读<br/>幻读]
    
    C --> C1[避免脏读<br/>可能不可重复读<br/>幻读]
    
    D --> D1[避免脏读<br/>不可重复读<br/>可能幻读]
    
    E --> E1[最高隔离级别<br/>避免所有并发问题<br/>串行执行]
    
    subgraph "隔离级别对比"
        F[级别越高<br/>并发性能越低<br/>数据一致性越好]
    end
    
    style E fill:#4caf50
    style D fill:#8bc34a
    style C fill:#ffc107
    style B fill:#f44336
```

### 10.6.2 隔离级别的实现

```mermaid
graph TD
    A[隔离级别实现] --> B[基于锁的实现]
    A --> C[基于MVCC的实现]
    
    B --> B1[读未提交: 写操作加X锁<br/>读操作不加锁]
    B --> B2[读已提交: 写操作加X锁到事务结束<br/>读操作加S锁立即释放]
    B --> B3[可重复读: 写操作加X锁到事务结束<br/>读操作加S锁到事务结束]
    B --> B4[串行化: 严格两段锁协议<br/>范围锁防止幻读]
    
    C --> C1[通过版本可见性<br/>实现不同隔离级别<br/>读操作不需要锁]
    
    subgraph "性能对比"
        D[MVCC实现<br/>读性能更好<br/>写性能略差]
        E[锁实现<br/>读性能较差<br/>写性能较好]
    end
    
    style C fill:#4caf50
    style D fill:#4caf50
```

## 10.7 并发控制的实现

### 10.7.1 锁管理器

```mermaid
graph TD
    A[锁管理器] --> B[锁表]
    A --> C[等待队列]
    A --> D[死锁检测]
    
    B --> B1[记录所有锁信息<br/>数据项、锁类型、持有者<br/>哈希表实现]
    
    C --> C1[管理等待锁的事务<br/>FIFO队列<br/>优先级队列]
    
    D --> D1[定期检测死锁<br/>构造等待图<br/>选择牺牲者]
    
    subgraph "锁操作"
        E[申请锁<br/>Lock Request]
        F[释放锁<br/>Lock Release]
        G[锁升级<br/>Lock Upgrade]
        H[锁降级<br/>Lock Downgrade]
    end
    
    style A fill:#e3f2fd
```

### 10.7.2 事务调度器

```mermaid
flowchart TD
    A[事务调度器] --> B[接收事务请求]
    B --> C[分析操作类型]
    C --> D{需要加锁?}
    D -->|是| E[向锁管理器申请锁]
    D -->|否| F[直接执行操作]
    E --> G{获得锁?}
    G -->|是| F
    G -->|否| H[加入等待队列]
    F --> I[执行数据库操作]
    I --> J[操作完成]
    
    subgraph "调度策略"
        K[先来先服务<br/>FCFS]
        L[优先级调度<br/>Priority]
        M[最短作业优先<br/>SJF]
    end
    
    style F fill:#4caf50
    style H fill:#ff9800
```

## 10.8 学习检查点

### 10.8.1 重点概念总结

```mermaid
mindmap
  root((并发控制))
    并发问题
      丢失修改
      不可重复读
      读脏数据
      幻读
    封锁方法
      锁类型
        共享锁S
        排他锁X
      封锁协议
        一级封锁协议
        二级封锁协议
        三级封锁协议
      两段锁协议
        扩展阶段
        收缩阶段
    死锁处理
      死锁预防
        一次封锁法
        顺序封锁法
      死锁检测
        等待图法
        超时法
      死锁解除
        选择牺牲者
        撤销事务
    其他方法
      时间戳排序
        基本时间戳
        多版本时间戳
      乐观控制
        验证技术
        多版本控制
    隔离级别
      读未提交
      读已提交
      可重复读
      串行化
```

### 10.8.2 练习题

1. **并发控制基础**
   - 分析并发操作可能产生的问题
   - 设计封锁协议解决并发问题
   - 比较不同封锁协议的效果

2. **死锁处理**
   - 构造死锁场景并用等待图检测
   - 设计死锁预防策略
   - 分析死锁解除的代价

3. **隔离级别应用**
   - 分析不同隔离级别的适用场景
   - 设计基于锁的隔离级别实现
   - 比较MVCC和锁机制的优缺点

### 10.8.3 思考题

1. 为什么两段锁协议能保证串行化？
2. 在什么情况下应该选择乐观并发控制？
3. MVCC如何解决读写冲突问题？
4. 如何在并发性能和数据一致性之间取得平衡？

---

**本章小结**：并发控制是数据库系统的核心技术之一，它确保多个事务并发执行时数据的一致性和隔离性。通过封锁、时间戳排序、乐观控制等方法，可以有效解决并发操作带来的问题。在实际应用中，需要根据应用特点选择合适的并发控制策略和隔离级别，在并发性能和数据一致性之间找到最佳平衡点。

---
**上一章：** [第9章 数据库恢复技术](第9章_数据库恢复技术.md)  
**下一章：** [第11章 数据库管理系统](第11章_数据库管理系统.md)